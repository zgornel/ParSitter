<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage examples · ParSitter</title><meta name="title" content="Usage examples · ParSitter"/><meta property="og:title" content="Usage examples · ParSitter"/><meta property="twitter:title" content="Usage examples · ParSitter"/><meta name="description" content="Documentation for ParSitter."/><meta property="og:description" content="Documentation for ParSitter."/><meta property="twitter:description" content="Documentation for ParSitter."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ParSitter</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Usage examples</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#CLI-based-parsing"><span>CLI-based parsing</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="github.com:zgornel/ParSitter.jl.git" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage-examples"><a class="docs-heading-anchor" href="#Usage-examples">Usage examples</a><a id="Usage-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-examples" title="Permalink"></a></h1><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>The library defines a single structure for working with trees, a <strong>tree-query-expression</strong> through <code>TreeQueryExpr</code> object. These can be constructed from <code>Tuples</code> or <code>NTuples</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ParSitter, AbstractTrees</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tt = (1,2,(3,(4,5,(6,),7,5)));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tq = ParSitter.build_tq_tree(tt)</code><code class="nohighlight hljs ansi" style="display:block;">ParSitter.TreeQueryExpr{Int64}(1, ParSitter.TreeQueryExpr[ParSitter.TreeQueryExpr{Int64}(2, ParSitter.TreeQueryExpr[]), ParSitter.TreeQueryExpr{Int64}(3, ParSitter.TreeQueryExpr[ParSitter.TreeQueryExpr{Int64}(4, ParSitter.TreeQueryExpr[ParSitter.TreeQueryExpr{Int64}(5, ParSitter.TreeQueryExpr[]), ParSitter.TreeQueryExpr{Int64}(6, ParSitter.TreeQueryExpr[]), ParSitter.TreeQueryExpr{Int64}(7, ParSitter.TreeQueryExpr[]), ParSitter.TreeQueryExpr{Int64}(5, ParSitter.TreeQueryExpr[])])])])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(tq, maxdepth=10)</code><code class="nohighlight hljs ansi" style="display:block;">1
├─ 2
└─ 3
   └─ 4
      ├─ 5
      ├─ 6
      ├─ 7
      └─ 5</code></pre><p>and converted back to <code>Tuples</code> and <code>NTuples</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; tt = convert(Tuple, tq)</code><code class="nohighlight hljs ansi" style="display:block;">(1, 2, (3, (4, 5, 6, 7, 5)))</code></pre><h3 id="Matching-trees"><a class="docs-heading-anchor" href="#Matching-trees">Matching trees</a><a id="Matching-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-trees" title="Permalink"></a></h3><p>Matching trees requires specifying functions that applied to a node of the tree extract its value for the purpose of comparison. A <em>capture function</em> needs to be provided for extracting a specific value from the node. These functions are necessary as target and query trees may contain complex nodes that are objects themselves and may need processing for matching and value capture to occur. In order to be able to match values and at the same time skip comparisons when capturing values, the argument <code>node_comparison_yields_true</code> needs to be specified. Its value should be a function that takes two nodes and returns true if the value needs to be captured.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; tt = ParSitter.build_tq_tree((1,2,(3,(4,)))); # a target tree</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tq = ParSitter.build_tq_tree((&quot;1&quot;,&quot;@v&quot;,&quot;3&quot;)); # a query tree, capture to &#39;v&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(tt)</code><code class="nohighlight hljs ansi" style="display:block;">1
├─ 2
└─ 3
   └─ 4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(tq)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;1&quot;
├─ &quot;@v&quot;
└─ &quot;3&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ParSitter.match_tree(
           tt,
           tq;
           target_tree_nodevalue = n-&gt;string(n.head),
           query_tree_nodevalue = n-&gt;n.head,
           capture_function = n-&gt;n.head,
           node_comparison_yields_true = (t1,t2) -&gt; true)  # all nodes will match!</code><code class="nohighlight hljs ansi" style="display:block;">(true, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(&quot;v&quot; =&gt; [2])), ParSitter.TreeQueryExpr{Int64}(1, ParSitter.TreeQueryExpr[ParSitter.TreeQueryExpr{Int64}(2, ParSitter.TreeQueryExpr[]), ParSitter.TreeQueryExpr{Int64}(3, ParSitter.TreeQueryExpr[ParSitter.TreeQueryExpr{Int64}(4, ParSitter.TreeQueryExpr[])])]))</code></pre><p>A full example which matches numerical trees to string queries:</p><pre><code class="language-julia hljs">using ParSitter, AbstractTrees

_query_tree_nodevalue(n) = ParSitter.is_capture_node(n).is_match ? split(n.head, &quot;@&quot;)[1] : n.head
_target_tree_nodevalue(n)=string(n.head)
_capture_on_empty_query_value(t1,t2) = ParSitter.is_capture_node(t2).is_match &amp;&amp; isempty(_query_tree_nodevalue(t2))

my_matcher(t,q) = ParSitter.match_tree(
                       ParSitter.build_tq_tree(t),
                       ParSitter.build_tq_tree(q);
                       target_tree_nodevalue=_target_tree_nodevalue,
                       query_tree_nodevalue=_query_tree_nodevalue,
                       capture_function=n-&gt;n.head,
                       node_comparison_yields_true=_capture_on_empty_query_value)

query = (&quot;1@v0&quot;, &quot;2&quot;, &quot;@v2&quot;)   # - query means: capture in &quot;v0&quot; if target value is 1, match on 2, capture any symbol in &quot;v2&quot;

t=(1,2,10); my_matcher( t, query)[1:2] |&gt; println
t=(10,2,11); my_matcher( t, query)[1:2] |&gt; println
t=(1,2,3,4,5); my_matcher( t, query)[1:2] |&gt; println</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(true, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(&quot;v2&quot; =&gt; [10], &quot;v0&quot; =&gt; [1])))
(false, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(&quot;v2&quot; =&gt; [11])))
(true, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(&quot;v2&quot; =&gt; [3], &quot;v0&quot; =&gt; [1])))</code></pre><h3 id="Querying-trees"><a class="docs-heading-anchor" href="#Querying-trees">Querying trees</a><a id="Querying-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-trees" title="Permalink"></a></h3><p>Tree queries match the query tree to the target tree and all its sub-trees.</p><pre><code class="language-julia hljs">using ParSitter, AbstractTrees

query = (&quot;1@v0&quot;, &quot;2&quot;, &quot;@v2&quot;)   # - query means: capture in &quot;v0&quot; if target value is 1, match on 2, capture any symbol in &quot;v2&quot;
target = (1, 2, 3, (10, 2, 3)) # - only the (1,2,3) sub-tree will match, the second will not bevause of the 10;
                               # - @v2 will always capture values (due to `_capture_on_empty_query_value`)
query_tq = ParSitter.build_tq_tree(query)
target_tq = ParSitter.build_tq_tree(target)

_query_tree_nodevalue(n) = ParSitter.is_capture_node(n).is_match ? split(n.head, &quot;@&quot;)[1] : n.head
_target_tree_nodevalue(n) = string(n.head)
_capture_on_empty_query_value(t1,t2) = ParSitter.is_capture_node(t2).is_match &amp;&amp; isempty(_query_tree_nodevalue(t2))
print_tree(target_tq); println(&quot;---&quot;)
print_tree(query_tq); println(&quot;---&quot;)
r=ParSitter.query(target_tq,
                  query_tq;
                  match_type=:strict,
                  target_tree_nodevalue=_target_tree_nodevalue,
                  query_tree_nodevalue=_query_tree_nodevalue,
                  capture_function=n-&gt;n.head,
                  node_comparison_yields_true=_capture_on_empty_query_value)
map(t-&gt;t[1:2], r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Tuple{Bool, DataStructures.MultiDict{Any, Any}}}:
 (1, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(&quot;v2&quot; =&gt; [3], &quot;v0&quot; =&gt; [1])))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(&quot;v2&quot; =&gt; [3])))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))</code></pre><pre><code class="language-julia hljs">r=ParSitter.query(target_tq,
                  query_tq;
                  match_type=:nonstrict,
                  target_tree_nodevalue=_target_tree_nodevalue,
                  query_tree_nodevalue=_query_tree_nodevalue,
                  capture_function=n-&gt;n.head,
                  node_comparison_yields_true=_capture_on_empty_query_value)
map(t-&gt;t[1:2], r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Tuple{Bool, DataStructures.MultiDict{Any, Any}}}:
 (1, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(&quot;v2&quot; =&gt; [3, 10], &quot;v0&quot; =&gt; [1])))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(&quot;v2&quot; =&gt; [3])))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))
 (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))</code></pre><h2 id="CLI-based-parsing"><a class="docs-heading-anchor" href="#CLI-based-parsing">CLI-based parsing</a><a id="CLI-based-parsing-1"></a><a class="docs-heading-anchor-permalink" href="#CLI-based-parsing" title="Permalink"></a></h2><p>ParSitter.jl comes with a command line tool that allows easy parsing of inline code, files and directories. Currently, it supports the following languages: <a href="https://www.python.org/">Python</a>, <a href="https://julialang.org/">Julia</a>, <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a>, <a href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)">C#</a> and <a href="https://www.r-project.org/">R</a></p><h3 id="Installing-tree-sitter-languages"><a class="docs-heading-anchor" href="#Installing-tree-sitter-languages">Installing <code>tree-sitter</code> languages</a><a id="Installing-tree-sitter-languages-1"></a><a class="docs-heading-anchor-permalink" href="#Installing-tree-sitter-languages" title="Permalink"></a></h3><p>In order to be able to parse code, <code>tree-sitter</code> and plugins for specific languages need to be installed. For example, to install the python language parser and Assuming that we want to install it to a directory named <code>_parsers</code>, located in the current directory, the following sequence of commands should do it:</p><pre><code class="language-sh hljs">cd _parsers
git clone https://github.com/tree-sitter/tree-sitter-python
cd tree-sitter-python
tree-sitter generate</code></pre><h3 id="Running-the-CLI-tool"><a class="docs-heading-anchor" href="#Running-the-CLI-tool">Running the CLI tool</a><a id="Running-the-CLI-tool-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-CLI-tool" title="Permalink"></a></h3><p>When ran, it returns a JSON string of the form:</p><pre><code class="nohighlight hljs">{ &quot;path/to/file&quot;:&quot;parsed code in XML format&quot;,
  ...
}</code></pre><p>For directories the JSON will contain more key-value paris and for inline code the file path key is an empty string. For example, the following command</p><pre><code class="language-sh hljs">julia --project parsitter.jl ./test/code/python/test_project/main.py --input-type file --language python --log-level error</code></pre><p>will result in</p><pre><code class="nohighlight hljs">{&quot;.../ParSitter.jl/test/code/python/test_project/main.py&quot;:&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&lt;module srow=\&quot;0\&quot; scol=\&quot;0\&quot; erow=\&quot;15\&quot; ecol=\&quot;0\&quot;&gt;  &lt;import_from_sta...
}</code></pre><blockquote><p>Note the <code>--escape-chars</code> option should be used if parsing inline code with <code>\n</code>, &#39;\t&#39; or &#39;\r&#39; characters.</p></blockquote><p>For example the following works,</p><pre><code class="language-sh hljs">$ julia parsitter.jl &#39;def foo():pass&#39; --input-type code --language python --log-level debug</code></pre><p>however if escape chars are present, use the <code>--escape-chars</code> option:</p><pre><code class="language-sh hljs">$ julia parsitter.jl &#39;def foo():\n\tpass&#39; --input-type code --escape-chars --language python --log-level debug</code></pre><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Saturday 28 February 2026 17:26">Saturday 28 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
