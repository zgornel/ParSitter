var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"\n\n","category":"section"},{"location":"api/#Base.convert-Union{Tuple{S}, Tuple{Type{ParSitter.TreeQueryExpr}, S}} where S","page":"API Reference","title":"Base.convert","text":"Convert a tree t to a TreeQueryExpr. The node value is returned by nodevalue and children of the node returned by children.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.convert-Union{Tuple{S}, Tuple{Type{Tuple}, S}} where S","page":"API Reference","title":"Base.convert","text":"Convert from a tree-like object to a Tuple.\n\nusing ParSitter\ntt=(1,2,(3,(4,5,(6,),7,5)));\ntq = ParSitter.build_tq_tree(tt)\ntt2 = convert(Tuple, tq)\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.build_tq_tree-Tuple{T} where T","page":"API Reference","title":"ParSitter.build_tq_tree","text":"build_tq_tree(t::Tuple)\n\nBuild a tree query expression tree out of a nested tuple: the assumption is that the first element of each tuple is the head of the expression, the rest are children.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.build_xml_tree-Tuple{String}","page":"API Reference","title":"ParSitter.build_xml_tree","text":"build_xml_tree(tree_sitter_xml_ast::String)\n\nPostprocesses and parse the tree-sitter XML output to something that can be traversed to match a given query.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.check_tq_tree-Tuple{ParSitter.TreeQueryExpr}","page":"API Reference","title":"ParSitter.check_tq_tree","text":"Checks that a query tree does not contain duplicate capture keys.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.get_capture-Tuple{AbstractVector, Any}","page":"API Reference","title":"ParSitter.get_capture","text":"Function that returns captured values from a query. If the key does not\nexist `nothing` is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.is_capture_node-Tuple{T} where T<:AbstractString","page":"API Reference","title":"ParSitter.is_capture_node","text":"is_capture_node(n; capture_sym=DEFAULT_CAPTURE_SYM)\n\nFunction that checks whether a node is a 'capture node' i.e. value of the form \"match@capture_key\" and returns a NamedTuple with the result and the capture key string\n\njulia> ParSitter.is_capture_node(\"value@capture_key\")\n(is_match = true, capture_key = \"capture_key\")\n\njulia> ParSitter.is_capture_node(\"value@capture_key\", capture_sym=\"@@\")\n(is_match = false, capture_key = nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.match_tree-Tuple{Any, Any}","page":"API Reference","title":"ParSitter.match_tree","text":"function match_tree(target_tree,\n                    query_tree;\n                    match_cache=Dict(),\n                    captured_symbols=MultiDict(),\n                    match_type=:strict,\n                    is_capture_node=is_capture_node,\n                    target_tree_nodevalue=AbstractTrees.nodevalue,\n                    query_tree_nodevalue=AbstractTrees.nodevalue,\n                    capture_function=AbstractTrees.nodevalue,\n                    node_comparison_yields_true=(args...)->false)\n\nFunction that searches a query_tree into a target_tree. It returns a vector of subtree matches, where each element is a Tuple that contains the result of the match, any captured values and the trees that were compared. To capture a value, the function is_capture_node must return true for a given query node. One example is using query nodes of  the form \"nodevalue@capture_variable\". In the matching process, the query and target node values are extracted using query_tree_nodevalue and target_tree_nodevalue respectively and compared. If they match, the target_tree node value is captured by applying capture_function to the node and a MultiDict(\"capture_variable\"=>captured_target_node_value)). Tree comparisons are also hashed and the result as well as captured symbols are stored in match_cache for quick retrieval.\n\nExample\n\njulia> using ParSitter\n       using AbstractTrees\n\n       _query_tree_nodevalue(n) = ParSitter.is_capture_node(n).is_match ? split(n.head, \"@\")[1] : n.head\n       _target_tree_nodevalue(n)=string(n.head)\n       _capture_on_empty_query_value(t1,t2) = ParSitter.is_capture_node(t2).is_match && isempty(_query_tree_nodevalue(t2))\n\n       my_matcher(t,q) = ParSitter.match_tree(\n                              ParSitter.build_tq_tree(t),\n                              ParSitter.build_tq_tree(q);\n                              target_tree_nodevalue=_target_tree_nodevalue,\n                              query_tree_nodevalue=_query_tree_nodevalue,\n                              capture_function=n->n.head,\n                              node_comparison_yields_true=_capture_on_empty_query_value)\n\n       query = (\"1@v0\", \"2\", \"@v2\")   # - query means: capture in \"v0\" if target value is 1, match on 2, capture any symbol in \"v2\"\n\n       t=(1,2,10); my_matcher( t, query)[1:2] |> println\n       t=(10,2,11); my_matcher( t, query)[1:2] |> println\n       t=(1,2,3,4,5); my_matcher( t, query)[1:2] |> println\n(true, MultiDict{Any, Any}(Dict{Any, Vector{Any}}(\"v2\" => [10], \"v0\" => [1])))\n(false, MultiDict{Any, Any}(Dict{Any, Vector{Any}}(\"v2\" => [11])))\n(true, MultiDict{Any, Any}(Dict{Any, Vector{Any}}(\"v2\" => [3], \"v0\" => [1])))\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.query-Tuple{Any, Any}","page":"API Reference","title":"ParSitter.query","text":"Query a tree with another tree. This will match the query_tree with all substrees of target_tree. Both trees should support the AbstractTrees interface.\n\nExample\n\njulia> using ParSitter\n       using AbstractTrees\n\n       query = (\"1@v0\", \"2\", \"@v2\")   # - query means: capture in \"v0\" if target value is 1, match on 2, capture any symbol in \"v2\"\n       target = (1, 2, 3, (10, 2, 3)) # - only the (1,2,3) subtree will match, the second will not bevause of the 10;\n                                      # - @v2 will always capture values (due to `_capture_on_empty_query_value`)\n       query_tq = ParSitter.build_tq_tree(query)\n       target_tq = ParSitter.build_tq_tree(target)\n\n       _query_tree_nodevalue(n) = ParSitter.is_capture_node(n).is_match ? split(n.head, \"@\")[1] : n.head\n       _target_tree_nodevalue(n) = string(n.head)\n       _capture_on_empty_query_value(t1,t2) = ParSitter.is_capture_node(t2).is_match && isempty(_query_tree_nodevalue(t2))\n       print_tree(target_tq); println(\"---\")\n       print_tree(query_tq); println(\"---\")\n       r=ParSitter.query(target_tq,\n                         query_tq;\n                         match_type=:strict,\n                         target_tree_nodevalue=_target_tree_nodevalue,\n                         query_tree_nodevalue=_query_tree_nodevalue,\n                         capture_function=n->n.head,\n                         node_comparison_yields_true=_capture_on_empty_query_value)\n       map(t->t[1:2], r)\n1\n├─ 2\n├─ 3\n└─ 10\n   ├─ 2\n   └─ 3\n---\n\"1@v0\"\n├─ \"2\"\n└─ \"@v2\"\n---\n6-element Vector{Tuple{Bool, MultiDict{Any, Any}}}:\n (1, MultiDict{Any, Any}(Dict{Any, Vector{Any}}(\"v2\" => [3], \"v0\" => [1])))\n (0, MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))\n (0, MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))\n (0, MultiDict{Any, Any}(Dict{Any, Vector{Any}}(\"v2\" => [3])))\n (0, MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))\n (0, MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))\n\njulia> r=ParSitter.query(target_tq,\n                         query_tq;\n                         match_type=:nonstrict,\n                         target_tree_nodevalue=_target_tree_nodevalue,\n                         query_tree_nodevalue=_query_tree_nodevalue,\n                         capture_function=n->n.head,\n                         node_comparison_yields_true=_capture_on_empty_query_value)\n       map(t->t[1:2], r)\n6-element Vector{Tuple{Bool, DataStructures.MultiDict{Any, Any}}}:\n (1, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(\"v2\" => [3, 10], \"v0\" => [1])))\n (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))\n (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))\n (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}(\"v2\" => [3])))\n (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))\n (0, DataStructures.MultiDict{Any, Any}(Dict{Any, Vector{Any}}()))\n\n\n\n\n\n","category":"method"},{"location":"examples/#Usage-examples","page":"Usage examples","title":"Usage examples","text":"","category":"section"},{"location":"examples/#A-first-example","page":"Usage examples","title":"A first example","text":"using ParSitter\nprint(\"OK\")\n\n","category":"section"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"This is a library for parsing code.\n\n","category":"section"}]
}
