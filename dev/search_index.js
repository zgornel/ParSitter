var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"\n\n","category":"section"},{"location":"api/#ParSitter.FILE_EXTENSIONS","page":"API Reference","title":"ParSitter.FILE_EXTENSIONS","text":"Map from input language to file extensions that can be parsed.\n\n\n\n\n\n","category":"constant"},{"location":"api/#ParSitter.LANGUAGE_MAP","page":"API Reference","title":"ParSitter.LANGUAGE_MAP","text":"Map from input language to tree-sitter compatible language name.\n\n\n\n\n\n","category":"constant"},{"location":"api/#ParSitter.TreeQueryExpr","page":"API Reference","title":"ParSitter.TreeQueryExpr","text":"TreeQueryExpr{T}(head::T, children::Vector{TreeQueryExpr})\n\nStructure used for the AbstractTrees interface. It allows to use Tuple-based S-expressions as query trees. ::T is the type of value used for the head as well as children. Usually, nodes are ::Strings.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.convert-Union{Tuple{S}, Tuple{Type{ParSitter.TreeQueryExpr}, S}} where S","page":"API Reference","title":"Base.convert","text":"Convert a tree t to a TreeQueryExpr. The node value is returned by nodevalue and children of the node returned by children.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.convert-Union{Tuple{S}, Tuple{Type{Tuple}, S}} where S","page":"API Reference","title":"Base.convert","text":"Convert from a tree-like object to a Tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.build_tq_tree-Tuple{T} where T","page":"API Reference","title":"ParSitter.build_tq_tree","text":"build_tq_tree(t::Tuple)\n\nBuild a tree query expression tree out of a nested tuple: the assumption is that the first element of each tuple is the head of the expression, the rest are children.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.build_xml_tree-Tuple{String}","page":"API Reference","title":"ParSitter.build_xml_tree","text":"build_xml_tree(tree_sitter_xml_ast::String)\n\nPostprocesses and parse the tree-sitter XML output to something that can be traversed to match a given query.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.check_tq_tree-Tuple{ParSitter.TreeQueryExpr}","page":"API Reference","title":"ParSitter.check_tq_tree","text":"Checks that a query tree does not contain duplicate capture keys.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.get_capture-Tuple{AbstractVector, Any}","page":"API Reference","title":"ParSitter.get_capture","text":"Function that returns captured values from a query. If the key does not exist nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.is_capture_node-Tuple{T} where T<:AbstractString","page":"API Reference","title":"ParSitter.is_capture_node","text":"is_capture_node(n; capture_sym=DEFAULT_CAPTURE_SYM)\n\nFunction that checks whether a node is a 'capture node' i.e. value of the form \"match@capture_key\" and returns a NamedTuple with the result and the capture key string\n\njulia> ParSitter.is_capture_node(\"value@capture_key\")\n(is_match = true, capture_key = \"capture_key\")\n\njulia> ParSitter.is_capture_node(\"value@capture_key\", capture_sym=\"@@\")\n(is_match = false, capture_key = nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.match_tree-Tuple{Any, Any}","page":"API Reference","title":"ParSitter.match_tree","text":"function match_tree(target_tree,\n                    query_tree;\n                    match_cache=Dict(),\n                    captured_symbols=MultiDict(),\n                    match_type=:strict,\n                    is_capture_node=is_capture_node,\n                    target_tree_nodevalue=AbstractTrees.nodevalue,\n                    query_tree_nodevalue=AbstractTrees.nodevalue,\n                    capture_function=AbstractTrees.nodevalue,\n                    node_comparison_yields_true=(args...)->false)\n\nFunction that searches a query_tree into a target_tree. It returns a vector of sub-tree matches, where each element is a Tuple that contains the result of the match, any captured values and the trees that were compared. To capture a value, the function is_capture_node must return true for a given query node. One example is using query nodes of  the form \"nodevalue@capture_variable\". In the matching process, the query and target node values are extracted using query_tree_nodevalue and target_tree_nodevalue respectively and compared. If they match, the target_tree node value is captured by applying capture_function to the node and a MultiDict(\"capture_variable\"=>captured_target_node_value)). The match_type argument, for :strict values will require trees to have the exact number of sub-trees and/or leaves. If the value is set to :nonstrict, additional leaves and sub-trees of the target tree will be ignored when matching. Tree comparisons are also hashed and the result as well as captured symbols are stored in match_cache for quick retrieval.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.parse-Tuple{ParSitter.Code, String}","page":"API Reference","title":"ParSitter.parse","text":"parse(code::Code, language::String; escape_chars=false, print_code=false)\n\nParsing function for ::Code objects. Calls the method for ::String. Use escape_chars=true if the code contains explicitly the ,  and  characters. If print_code is true it will print the code.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.parse-Tuple{ParSitter.Directory, String}","page":"API Reference","title":"ParSitter.parse","text":"parse(code::Directory, language::String)\n\nParsing function for ::Directory objects. Reads the contents of the directory and for supported files, calls the parsing method for ::File objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.parse-Tuple{ParSitter.File, String}","page":"API Reference","title":"ParSitter.parse","text":"parse(code::File, language::String)\n\nParsing function for ::File objects. Reads the content of the file, sends it to tree-sitter for parsing and returns the parse results.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.parse-Tuple{String, String}","page":"API Reference","title":"ParSitter.parse","text":"parse(code::String, language::String; escape_chars=false, print_code=false)\n\nParsing function for strings. Use escape_chars=true if the code contains explicitly the ,  and  characters. If print_code is true it will print the code.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParSitter.query-Tuple{Any, Any}","page":"API Reference","title":"ParSitter.query","text":"Query a tree with another tree. This will match the query_tree with all sub-trees of target_tree. Both trees should support the AbstractTrees interface.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Usage-examples","page":"Usage examples","title":"Usage examples","text":"","category":"section"},{"location":"examples/#Getting-started","page":"Usage examples","title":"Getting started","text":"The library defines a single structure for working with trees, a tree-query-expression through TreeQueryExpr object. These can be constructed from Tuples or NTuples\n\nusing ParSitter, AbstractTrees\ntt = (1,2,(3,(4,5,(6,),7,5)));\ntq = ParSitter.build_tq_tree(tt)\nprint_tree(tq, maxdepth=10)\n\nand converted back to Tuples and NTuples:\n\ntt = convert(Tuple, tq)","category":"section"},{"location":"examples/#Matching-trees","page":"Usage examples","title":"Matching trees","text":"Matching trees requires specifying functions that applied to a node of the tree extract its value for the purpose of comparison. A capture function needs to be provided for extracting a specific value from the node. These functions are necessary as target and query trees may contain complex nodes that are objects themselves and may need processing for matching and value capture to occur. In order to be able to match values and at the same time skip comparisons when capturing values, the argument node_comparison_yields_true needs to be specified. Its value should be a function that takes two nodes and returns true if the value needs to be captured.\n\ntt = ParSitter.build_tq_tree((1,2,(3,(4,)))); # a target tree\ntq = ParSitter.build_tq_tree((\"1\",\"@v\",\"3\")); # a query tree, capture to 'v'\nprint_tree(tt)\nprint_tree(tq)\nParSitter.match_tree(\n    tt,\n    tq;\n    target_tree_nodevalue = n->string(n.head),\n    query_tree_nodevalue = n->n.head,\n    capture_function = n->n.head,\n    node_comparison_yields_true = (t1,t2) -> true)  # all nodes will match!\n\nA full example which matches numerical trees to string queries:\n\nusing ParSitter, AbstractTrees\n\n_query_tree_nodevalue(n) = ParSitter.is_capture_node(n).is_match ? split(n.head, \"@\")[1] : n.head\n_target_tree_nodevalue(n)=string(n.head)\n_capture_on_empty_query_value(t1,t2) = ParSitter.is_capture_node(t2).is_match && isempty(_query_tree_nodevalue(t2))\n\nmy_matcher(t,q) = ParSitter.match_tree(\n                       ParSitter.build_tq_tree(t),\n                       ParSitter.build_tq_tree(q);\n                       target_tree_nodevalue=_target_tree_nodevalue,\n                       query_tree_nodevalue=_query_tree_nodevalue,\n                       capture_function=n->n.head,\n                       node_comparison_yields_true=_capture_on_empty_query_value)\n\nquery = (\"1@v0\", \"2\", \"@v2\")   # - query means: capture in \"v0\" if target value is 1, match on 2, capture any symbol in \"v2\"\n\nt=(1,2,10); my_matcher( t, query)[1:2] |> println\nt=(10,2,11); my_matcher( t, query)[1:2] |> println\nt=(1,2,3,4,5); my_matcher( t, query)[1:2] |> println","category":"section"},{"location":"examples/#Querying-trees","page":"Usage examples","title":"Querying trees","text":"Tree queries match the query tree to the target tree and all its sub-trees.\n\nusing ParSitter, AbstractTrees\n\nquery = (\"1@v0\", \"2\", \"@v2\")   # - query means: capture in \"v0\" if target value is 1, match on 2, capture any symbol in \"v2\"\ntarget = (1, 2, 3, (10, 2, 3)) # - only the (1,2,3) sub-tree will match, the second will not bevause of the 10;\n                               # - @v2 will always capture values (due to `_capture_on_empty_query_value`)\nquery_tq = ParSitter.build_tq_tree(query)\ntarget_tq = ParSitter.build_tq_tree(target)\n\n_query_tree_nodevalue(n) = ParSitter.is_capture_node(n).is_match ? split(n.head, \"@\")[1] : n.head\n_target_tree_nodevalue(n) = string(n.head)\n_capture_on_empty_query_value(t1,t2) = ParSitter.is_capture_node(t2).is_match && isempty(_query_tree_nodevalue(t2))\nprint_tree(target_tq); println(\"---\")\nprint_tree(query_tq); println(\"---\")\nr=ParSitter.query(target_tq,\n                  query_tq;\n                  match_type=:strict,\n                  target_tree_nodevalue=_target_tree_nodevalue,\n                  query_tree_nodevalue=_query_tree_nodevalue,\n                  capture_function=n->n.head,\n                  node_comparison_yields_true=_capture_on_empty_query_value)\nmap(t->t[1:2], r)\n\nr=ParSitter.query(target_tq,\n                  query_tq;\n                  match_type=:nonstrict,\n                  target_tree_nodevalue=_target_tree_nodevalue,\n                  query_tree_nodevalue=_query_tree_nodevalue,\n                  capture_function=n->n.head,\n                  node_comparison_yields_true=_capture_on_empty_query_value)\nmap(t->t[1:2], r)","category":"section"},{"location":"examples/#CLI-based-parsing","page":"Usage examples","title":"CLI-based parsing","text":"ParSitter comes with a command line tool that allows easy parsing of inline code, files and directories. Currently, it supports the following languages: Python, Julia, C, C# and R","category":"section"},{"location":"examples/#Installing-tree-sitter-languages","page":"Usage examples","title":"Installing tree-sitter languages","text":"In order to be able to parse code, tree-sitter and plugins for specific languages need to be installed. For example, to install the python language parser and Assuming that we want to install it to a directory named _parsers, located in the current directory, the following sequence of commands should do it:\n\ncd _parsers\ngit clone https://github.com/tree-sitter/tree-sitter-python\ncd tree-sitter-python\ntree-sitter generate","category":"section"},{"location":"examples/#Running-the-CLI-tool","page":"Usage examples","title":"Running the CLI tool","text":"When ran, it returns a JSON string of the form:\n\n{ \"path/to/file\":\"parsed code in XML format\",\n  ...\n}\n\nFor directories the JSON will contain more key-value paris and for inline code the file path key is an empty string. For example, the following command\n\njulia --project parsitter.jl ./test/code/python/test_project/main.py --input-type file --language python --log-level error\n\nwill result in\n\n{\".../ParSitter/test/code/python/test_project/main.py\":\"<?xml version=\\\"1.0\\\"?><module srow=\\\"0\\\" scol=\\\"0\\\" erow=\\\"15\\\" ecol=\\\"0\\\">  <import_from_sta...\n}\n\nNote the --escape-chars option should be used if parsing inline code with \\n, '\\t' or '\\r' characters.\n\nFor example the following works,\n\n$ julia parsitter.jl 'def foo():pass' --input-type code --language python --log-level debug\n\nhowever if escape chars are present, use the --escape-chars option:\n\n$ julia parsitter.jl 'def foo():\\n\\tpass' --input-type code --escape-chars --language python --log-level debug\n\n","category":"section"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"ParSitter is a library for parsing and querying code. It supports parsing of code to abstract syntax trees (ASTs) and extracting information from the trees by executing code queries over the ASTs. This paper provides a nice introduction into the main concepts behind the matching.\n\nA code query is basically tree pattern matching with capturing of values. Throughout the documentation we shall refer to:\n\ntarget tree the tree which one queries\nquery tree the tree which is used extract values from the target tree.","category":"section"},{"location":"#Features","page":"Introduction","title":"Features","text":"parsing of Python, Julia, C, C# and R through tree-sitter\ntree matching using queries that can be expressed as Tuples (in an S-Expression fashion)","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"The installation can be done by manually by cloning the repository with:\n\ngit clone https://github.com/zgornel/ParSitter","category":"section"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"Pages = [\"examples.md\", \"api.md\"]\nDepth = 3\n\n","category":"section"}]
}
